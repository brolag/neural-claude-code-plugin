# CRAFT Framework Template
# Context, Requirements, Actions, Flow, Tests
# For autonomous prompts that need clear structure
#
# Neural Claude Code - Agentic Prompt Engineering

# =============================================================================
# CRAFT PROMPT TEMPLATE
# =============================================================================
# Use this template when creating prompts for:
# - AFK (away from keyboard) autonomous sessions
# - Complex multi-step tasks
# - Tasks that need clear success criteria
# =============================================================================

# =============================================================================
# THE 6 CORE AREAS
# =============================================================================
# Every spec should cover these 6 areas for completeness:
#
# 1. COMMANDS     - Full executable commands with flags
# 2. TESTING      - Framework, locations, coverage expectations
# 3. STRUCTURE    - Clear directory organization
# 4. CODE STYLE   - One real snippet > lengthy descriptions
# 5. GIT WORKFLOW - Branch naming, commit format, PR requirements
# 6. BOUNDARIES   - What agents should NEVER touch
# =============================================================================

# =============================================================================
# 3-TIER BOUNDARY SYSTEM
# =============================================================================
# âœ… ALWAYS DO   - Safe actions, no approval needed
# âš ï¸ ASK FIRST   - High-impact, needs human review
# ğŸš« NEVER DO    - Hard stops, forbidden actions
# =============================================================================

craft:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # C - CONTEXT
  # What is the current situation? What does the agent need to know?
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  context:
    description: |
      # Describe the current state
      # - What project/codebase is this?
      # - What's already done?
      # - What constraints exist?

    codebase_state: |
      # Current state of relevant files
      # - List key files and their purpose
      # - Note any technical debt or issues

    constraints:
      - # Budget/time constraints
      - # Technical constraints (no breaking changes, etc.)
      - # Security requirements

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # R - REQUIREMENTS
  # What exactly needs to be achieved? What does success look like?
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  requirements:
    objective: |
      # Clear, specific goal
      # - What should exist when done?
      # - What problem does this solve?

    success_criteria:
      - # Criterion 1: Tests pass
      - # Criterion 2: Feature works as described
      - # Criterion 3: No regressions

    out_of_scope:
      - # Things NOT to do
      - # Prevents scope creep

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # A - ACTIONS
  # What transformations/operations should happen?
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  actions:
    rules:
      - # Rule 1: Follow existing patterns
      - # Rule 2: No new dependencies without approval
      - # Rule 3: One file at a time

    allowed_operations:
      - read_files
      - write_files
      - run_tests
      - run_linter
      # Add more as needed

    forbidden_operations:
      - delete_production_data
      - push_to_main
      - modify_ci_config

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # F - FLOW
  # What are the execution steps? In what order?
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  flow:
    steps:
      - step: 1
        action: "Explore and understand"
        details: |
          - Read relevant files
          - Understand current implementation
          - Identify what needs to change

      - step: 2
        action: "Plan the changes"
        details: |
          - List files to modify
          - Define order of changes
          - Identify risks

      - step: 3
        action: "Implement changes"
        details: |
          - Make one change at a time
          - Run tests after each change
          - Commit at logical checkpoints

      - step: 4
        action: "Validate"
        details: |
          - Run full test suite
          - Check for regressions
          - Verify success criteria

    iteration_strategy: |
      # How to handle iterations
      # - Pick highest priority incomplete item
      # - Complete one thing before starting another
      # - Stop when all criteria met

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # T - TESTS
  # How to verify completion? What signals success?
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  tests:
    automated_checks:
      - command: "npm test"
        expected: "All tests pass"

      - command: "npm run lint"
        expected: "No errors"

      - command: "npm run typecheck"
        expected: "No type errors"

    manual_verification:
      - # What should a human check?
      - # Edge cases to verify

    completion_promise: |
      # The exact phrase that signals completion
      # Agent outputs this when ALL criteria met
      <promise>CRAFT_COMPLETE</promise>

    failure_signals:
      - "Tests failing repeatedly"
      - "Circular dependency detected"
      - "Breaking changes to public API"

# =============================================================================
# EXAMPLE: Feature Implementation
# =============================================================================
example_feature:
  context:
    description: |
      Adding user authentication to a Next.js app.
      Currently has basic pages but no auth.
      Using Prisma for database.

    codebase_state: |
      - pages/index.tsx - Landing page
      - pages/dashboard.tsx - Needs protection
      - prisma/schema.prisma - Has User model

    constraints:
      - Must use NextAuth.js
      - No paid auth providers
      - Session-based, not JWT

  requirements:
    objective: |
      Users can sign up, log in, and access protected pages.
      Dashboard only accessible when authenticated.

    success_criteria:
      - User can create account with email/password
      - User can log in and see dashboard
      - Unauthenticated users redirected to login
      - Tests cover happy path and edge cases

    out_of_scope:
      - OAuth providers (future work)
      - Password reset (future work)
      - Email verification (future work)

  actions:
    rules:
      - Use existing User model in Prisma
      - Follow Next.js 14 patterns
      - No breaking changes to existing pages

    allowed_operations:
      - Create new files in pages/api/auth
      - Modify pages to add auth checks
      - Add auth-related tests

  flow:
    steps:
      - step: 1
        action: "Install NextAuth.js"
        details: "npm install next-auth"

      - step: 2
        action: "Create auth API routes"
        details: "pages/api/auth/[...nextauth].ts"

      - step: 3
        action: "Add session provider"
        details: "Wrap _app.tsx"

      - step: 4
        action: "Protect dashboard"
        details: "Add useSession check"

      - step: 5
        action: "Create login page"
        details: "pages/login.tsx"

      - step: 6
        action: "Add tests"
        details: "Test login flow"

  tests:
    automated_checks:
      - command: "npm test -- --grep auth"
        expected: "Auth tests pass"

    completion_promise: |
      <promise>CRAFT_COMPLETE</promise>

# =============================================================================
# QUICK TEMPLATE (for simple tasks)
# =============================================================================
quick_craft:
  context: |
    [What's the current situation?]

  requirements: |
    [What exactly should be done?]

  actions: |
    [What operations are allowed?]

  flow: |
    [What are the steps?]

  tests: |
    [How do we know it's done?]
    <promise>DONE</promise>

# =============================================================================
# 6 CORE AREAS CHECKLIST
# =============================================================================
# Include in every spec for completeness
six_core_areas:
  commands:
    build: "npm run build"
    test: "npm test"
    lint: "npm run lint"
    typecheck: "npm run typecheck"
    dev: "npm run dev"

  testing:
    framework: "jest"           # or vitest, pytest, etc.
    location: "tests/"          # or __tests__, src/**/*.test.ts
    coverage_target: 80         # minimum coverage %
    run_before_commit: true

  structure:
    src: "Source code"
    tests: "Test files"
    docs: "Documentation"
    scripts: "Build/deploy scripts"

  code_style:
    example: |
      // ONE real example beats lengthy descriptions
      async function fetchUser(id: string): Promise<User> {
        const response = await api.get(`/users/${id}`);
        return response.data;
      }

  git_workflow:
    branch_naming: "feature/description-here"
    commit_format: "feat: description"
    pr_required: true
    review_required: true

  boundaries:
    always_do:
      - "Run tests before commits"
      - "Run linter before commits"
      - "Use TypeScript strict mode"
    ask_first:
      - "Database schema changes"
      - "New dependencies"
      - "API contract changes"
      - "CI/CD modifications"
    never_do:
      - "Commit secrets or API keys"
      - "Push directly to main"
      - "Delete production data"
      - "Disable security features"

# =============================================================================
# 3-TIER BOUNDARIES TEMPLATE
# =============================================================================
boundaries_template:
  # âœ… ALWAYS DO - Safe actions, no approval needed
  always:
    - "Run tests before commits"
    - "Follow existing code patterns"
    - "Add comments for complex logic"
    - "Update related tests when changing code"

  # âš ï¸ ASK FIRST - High-impact, needs human review
  ask_first:
    - "Adding new dependencies"
    - "Changing database schema"
    - "Modifying public API contracts"
    - "Updating authentication logic"
    - "Changes to CI/CD pipeline"

  # ğŸš« NEVER DO - Hard stops, forbidden
  never:
    - "Commit API keys, passwords, or secrets"
    - "Push directly to main/master branch"
    - "Delete or modify production data"
    - "Disable security checks or linting"
    - "Remove tests without replacement"
    - "Bypass code review process"

# =============================================================================
# THE 70% PROBLEM REMINDER
# =============================================================================
# AI produces ~70% of code fast, but the 30% (edge cases, security,
# integration) takes just as long as ever.
#
# Implications for specs:
# - Be specific about edge cases upfront
# - Include security requirements explicitly
# - Define integration points clearly
# - Don't skip the "boring" validation work
# =============================================================================

# =============================================================================
# SPEC-DRIVEN DEVELOPMENT PHASES
# =============================================================================
spec_driven_dev:
  phase_1_specify:
    description: "Create detailed spec with UX and success criteria"
    output: "spec.md"

  phase_2_plan:
    description: "Generate technical plan with architecture"
    output: "plan.md"
    note: "Waterfall in 15 minutes"

  phase_3_tasks:
    description: "Break into small, reviewable chunks"
    output: "tasks.json or todo.md"

  phase_4_implement:
    description: "Execute tasks one by one with validation"
    output: "Working code + tests"

# =============================================================================
# CONTEXT MANAGEMENT TIPS
# =============================================================================
# "More tokens = diminishing returns"
#
# Strategies:
# 1. Extended TOC/Summaries - Condense large specs into hierarchical summaries
# 2. Sub-agents/Skills - Specialized agents with only relevant context
# 3. Parallel Agents - Multiple agents on non-overlapping work
# 4. Modular Prompts - Refresh context per task, not cumulative
# =============================================================================
